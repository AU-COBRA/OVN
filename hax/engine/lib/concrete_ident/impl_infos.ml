open! Prelude

type t = {
  trait_goal : Ast.Rust.trait_goal option;
      (** The trait implemented by the [impl] block or [None] if the
         [impl] block is an {{: https://doc.rust-lang.org/reference/items/implementations.html#inherent-implementations } inherent [impl]}.
        *)
  typ : Ast.Rust.ty;  (** The type implemented by the [impl] block. *)
  clauses : Ast.Rust.trait_goal list;
      (** The clauses that constraint this [impl] block. *)
}
(** metadata of an [impl] block *)

(** Lookup the implementation informations given a concrete
ident. Returns [Some _] if and only if the supplied identifier points
to an [Impl].

{b WARNING}: due to {{: https://github.com/hacspec/hax/issues/363}
issue 363}, when looking up certain identifiers generated by the
engine, this function may return [None] even though the supplied
identifier points to an [Impl] block. *)
let lookup span (impl : Concrete_ident.t) : t option =
  let* Types.{ generics = _; clauses; typ; trait_ref } =
    Concrete_ident.lookup_raw_impl_info impl
  in
  let trait_goal =
    Option.map ~f:(Import_thir.import_trait_ref span) trait_ref
  in
  let typ = Import_thir.import_ty span typ in
  let clauses =
    let f ((binder : Types.clause), span) =
      Import_thir.import_clause span binder
    in
    List.filter_map ~f clauses
    |> List.filter_map ~f:(fun (c : Ast.Rust.generic_constraint) ->
           match c with GCType i -> Some i.goal | _ -> None)
  in
  Some { trait_goal; typ; clauses }

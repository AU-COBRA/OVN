---
source: test-harness/src/harness.rs
expression: snapshot
info:
  kind:
    Translate:
      backend: ssprove
  info:
    name: enum-repr
    manifest: enum-repr/Cargo.toml
    description: ~
  spec:
    optional: false
    broken: false
    issue_id: ~
    positive: true
    snapshot:
      stderr: true
      stdout: true
    include_flag: ~
    backend_options: ~
---
exit = 0
stderr = 'Finished `dev` profile [unoptimized + debuginfo] target(s) in XXs'

[stdout]
diagnostics = []

[stdout.files]
"Enum_repr.v" = '''
(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
From Jasmin Require Import word.

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Equations discriminant_EnumWithRepr_ExplicitDiscr1 {L : {fset Location}} {I : Interface} : both L I int16 :=
  discriminant_EnumWithRepr_ExplicitDiscr1  :=
    solve_lift (ret_both (1 : int16)) : both L I int16.
Fail Next Obligation.

Equations discriminant_EnumWithRepr_ExplicitDiscr2 {L : {fset Location}} {I : Interface} : both L I int16 :=
  discriminant_EnumWithRepr_ExplicitDiscr2  :=
    solve_lift (ret_both (5 : int16)) : both L I int16.
Fail Next Obligation.

Definition t_EnumWithRepr : choice_type :=
  ('unit ∐ 'unit ∐ 'unit ∐ 'unit).
Notation "'EnumWithRepr_ExplicitDiscr1_case'" := (inl (inl (inl tt))) (at level 100).
Equations EnumWithRepr_ExplicitDiscr1 {L : {fset Location}} {I : Interface} : both L I t_EnumWithRepr :=
  EnumWithRepr_ExplicitDiscr1  :=
    solve_lift (ret_both (inl (inl (inl (tt : 'unit))) : t_EnumWithRepr)) : both L I t_EnumWithRepr.
Fail Next Obligation.
Notation "'EnumWithRepr_ExplicitDiscr2_case'" := (inl (inl (inr tt))) (at level 100).
Equations EnumWithRepr_ExplicitDiscr2 {L : {fset Location}} {I : Interface} : both L I t_EnumWithRepr :=
  EnumWithRepr_ExplicitDiscr2  :=
    solve_lift (ret_both (inl (inl (inr (tt : 'unit))) : t_EnumWithRepr)) : both L I t_EnumWithRepr.
Fail Next Obligation.
Notation "'EnumWithRepr_ImplicitDiscrEmptyTuple_case'" := (inl (inr tt)) (at level 100).
Equations EnumWithRepr_ImplicitDiscrEmptyTuple {L : {fset Location}} {I : Interface} : both L I t_EnumWithRepr :=
  EnumWithRepr_ImplicitDiscrEmptyTuple  :=
    solve_lift (ret_both (inl (inr (tt : 'unit)) : t_EnumWithRepr)) : both L I t_EnumWithRepr.
Fail Next Obligation.
Notation "'EnumWithRepr_ImplicitDiscrEmptyStruct_case'" := (inr tt) (at level 100).
Equations EnumWithRepr_ImplicitDiscrEmptyStruct {L : {fset Location}} {I : Interface} : both L I t_EnumWithRepr :=
  EnumWithRepr_ImplicitDiscrEmptyStruct  :=
    solve_lift (ret_both (inr (tt : 'unit) : t_EnumWithRepr)) : both L I t_EnumWithRepr.
Fail Next Obligation.

Equations t_EnumWithRepr_cast_to_repr {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 t_EnumWithRepr) : both L1 I1 int16 :=
  t_EnumWithRepr_cast_to_repr x  :=
    matchb x with
    | EnumWithRepr_ExplicitDiscr1_case  =>
      solve_lift discriminant_EnumWithRepr_ExplicitDiscr1
    | EnumWithRepr_ExplicitDiscr2_case  =>
      solve_lift discriminant_EnumWithRepr_ExplicitDiscr2
    | EnumWithRepr_ImplicitDiscrEmptyTuple_case  =>
      solve_lift (discriminant_EnumWithRepr_ExplicitDiscr2 .+ (ret_both (1 : int16)))
    | EnumWithRepr_ImplicitDiscrEmptyStruct_case  =>
      solve_lift (discriminant_EnumWithRepr_ExplicitDiscr2 .+ (ret_both (2 : int16)))
    end : both L1 I1 int16.
Fail Next Obligation.

(*Not implemented yet? todo(item)*)

Equations f {L1 : {fset Location}} {I1 : Interface} (_ : both L1 I1 'unit) : both L1 I1 int32 :=
  f _  :=
    letb v__x := cast_int (WS2 := _) (discriminant_EnumWithRepr_ExplicitDiscr2 .+ (ret_both (0 : int16))) in
    solve_lift ((cast_int (WS2 := _) (t_EnumWithRepr_cast_to_repr EnumWithRepr_ImplicitDiscrEmptyTuple)) .+ (cast_int (WS2 := _) (t_EnumWithRepr_cast_to_repr EnumWithRepr_ImplicitDiscrEmptyStruct))) : both L1 I1 int32.
Fail Next Obligation.

Equations ff__CONST {L : {fset Location}} {I : Interface} : both L I int16 :=
  ff__CONST  :=
    solve_lift (cast_int (WS2 := _) (discriminant_EnumWithRepr_ExplicitDiscr1 .+ (ret_both (0 : int16)))) : both L I int16.
Fail Next Obligation.

Equations get_casted_repr {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 t_EnumWithRepr) : both L1 I1 int64 :=
  get_casted_repr x  :=
    solve_lift (cast_int (WS2 := _) (t_EnumWithRepr_cast_to_repr x)) : both L1 I1 int64.
Fail Next Obligation.

Equations get_repr {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 t_EnumWithRepr) : both L1 I1 int16 :=
  get_repr x  :=
    solve_lift (t_EnumWithRepr_cast_to_repr x) : both L1 I1 int16.
Fail Next Obligation.
'''

(* File automatically generated by Hacspec *)
From Hacspec Require Import Hacspec_Lib MachineIntegers.
From Coq Require Import ZArith.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.

Inductive t_Side : Type :=
| Side_Buyt_Side
| Side_Sellt_Side.

Record t_Order : Type :={
  f_quantity : int64;
  f_price : int64;
  f_side : t_Side_t;
  f_id : int64;
}.

Record t_Match : Type :={
  f_quantity : int64;
  f_price : int64;
  f_ask_id : int64;
  f_bid_id : int64;
}.

Definition is_match (order : t_Order_t) (other : t_Order_t) : bool :=
  andb (andb (andb ((f_quantity order)>.?(@repr WORDSIZE64 0)) ((f_quantity other)>.?(@repr WORDSIZE64 0))) ((f_side order)<>(f_side other))) (orb (andb ((f_side order)=.?Side_Buyt_Side_t) ((f_price order)>=.?(f_price other))) (andb ((f_side order)=.?Side_Sellt_Side_t) ((f_price order)<=.?(f_price other)))).

Definition impl__Order__try_match (self : t_Order_t) (other : t_Order_t) : t_Option_t t_Match_t :=
  if
    is_match self other
  then
    let quantity := (min (f_quantity self) (f_quantity other)) : int64 in
    let '(bid_id,ask_id) := (if
        (f_side self)=.?Side_Buyt_Side_t
      then
        (f_id self,f_id other)
      else
        (f_id other,f_id self)) : (int64 × int64) in
    Option_Some (Build_Match bid_idask_id(f_price self)quantity)
  else
    Option_Nonet_Option_t t_Match_t.

Definition process_order (order : t_Order_t) (other_side : t_BinaryHeap_t T) : (t_BinaryHeap_t T × (t_Vec_t (t_Match_t) (t_Global_t) × t_Option_t t_Order_t)) :=
  let matches := (impl__new) : t_Vec_t (t_Match_t) (t_Global_t) in
  let done := (false) : bool in
  let '(done,matches,order,other_side) := (f_fold (f_into_iter (Build_Range (@repr WORDSIZE32 1)(impl_10__len other_side))) (done,matches,order,other_side) (fun '(done,matches,order,other_side) _i =>
      if
        not done
      then
        match impl__and_then (impl_10__peek other_side) (fun other =>
            impl__Order__try_match (f_into (f_clone other)) order) with
        | Option_Some m => let order := (Build_t_Order ((f_quantity order).-(f_quantity m))) : t_Order_t in
          let '(tmp0,out) := (impl_9__pop other_side) : (t_BinaryHeap_t T × t_Option_t T) in
          let other_side := (tmp0) : t_BinaryHeap_t T in
          let hoist1 := (out) : t_Option_t T in
          let hoist2 := (impl__unwrap hoist1) : T in
          let other := (f_into hoist2) : t_Order_t in
          let other := (Build_t_Order ((f_quantity other).-(f_quantity m))) : t_Order_t in
          let other_side := (if
              (f_quantity other)>.?(@repr WORDSIZE64 0)
            then
              let other_side := (impl_9__push other_side (f_from (f_clone other))) : t_BinaryHeap_t T in
              other_side
            else
              other_side) : t_BinaryHeap_t T in
          let matches := (impl_1__push matches m) : t_Vec_t (t_Match_t) (t_Global_t) in
          (done,matches,order,other_side)
        | _ => let done := (true) : bool in
          (done,matches,order,other_side)
        end
      else
        (done,matches,order,other_side))) : (bool × t_Vec_t (t_Match_t) (t_Global_t) × t_Order_t × t_BinaryHeap_t T) in
  let output := ((matches,if
        (f_quantity order)>.?(@repr WORDSIZE64 0)
      then
        Option_Some order
      else
        Option_Nonet_Option_t t_Order_t)) : (t_Vec_t (t_Match_t) (t_Global_t) × t_Option_t t_Order_t) in
  (other_side,output).

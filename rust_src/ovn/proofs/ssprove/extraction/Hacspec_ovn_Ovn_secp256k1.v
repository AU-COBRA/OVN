(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From SSProve Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Require Import Hacspec_concordium.
Export Hacspec_concordium.

Require Import Crate_Ovn_traits.
Export Crate_Ovn_traits.

Require Import Hacspec_lib.
Export Hacspec_lib.

Require Import Hacspec_bip_340.
Export Hacspec_bip_340.

Definition t_Group_curve : choice_type :=
  (t_Point).
Equations f_g_val (s : both t_Group_curve) : both t_Point :=
  f_g_val s  :=
    bind_both s (fun x =>
      ret_both (x : t_Point)) : both t_Point.
Fail Next Obligation.
Equations Build_t_Group_curve {f_g_val : both t_Point} : both (t_Group_curve) :=
  Build_t_Group_curve  :=
    bind_both f_g_val (fun f_g_val =>
      ret_both ((f_g_val) : (t_Group_curve))) : both (t_Group_curve).
Fail Next Obligation.
Notation "'Build_t_Group_curve' '[' x ']' '(' 'f_g_val' ':=' y ')'" := (Build_t_Group_curve (f_g_val := y)).

Definition t_Z_curve : choice_type :=
  (t_Scalar).
Equations f_z_val (s : both t_Z_curve) : both t_Scalar :=
  f_z_val s  :=
    bind_both s (fun x =>
      ret_both (x : t_Scalar)) : both t_Scalar.
Fail Next Obligation.
Equations Build_t_Z_curve {f_z_val : both t_Scalar} : both (t_Z_curve) :=
  Build_t_Z_curve  :=
    bind_both f_z_val (fun f_z_val =>
      ret_both ((f_z_val) : (t_Z_curve))) : both (t_Z_curve).
Fail Next Obligation.
Notation "'Build_t_Z_curve' '[' x ']' '(' 'f_z_val' ':=' y ')'" := (Build_t_Z_curve (f_z_val := y)).

#[global] Program Instance t_Z_curve_t_Deserial : t_Deserial t_Z_curve :=
  let f_deserial := fun  (source : both v_R) => run (letb '(tmp0,out) := f_get source in
  letb source := tmp0 in
  letb hoist3 := out in
  letb hoist4 := f_branch hoist3 in
  letm[choice_typeMonad.result_bind_code (v_R × t_Result t_Z_curve t_ParseError)] (temp : t_Vec int8 t_Global) := matchb hoist4 with
  | ControlFlow_Break_case residual =>
    letb residual := ret_both ((residual) : (t_Result t_Infallible t_ParseError)) in
    letm[choice_typeMonad.result_bind_code (v_R × t_Result t_Z_curve t_ParseError)] hoist2 := ControlFlow_Break (prod_b (source,f_from_residual residual)) in
    ControlFlow_Continue (never_to_any hoist2)
  | ControlFlow_Continue_case val =>
    letb val := ret_both ((val) : (t_Vec int8 t_Global)) in
    ControlFlow_Continue val
  end in
  ControlFlow_Continue (letb hax_temp_output := Result_Ok (Build_t_Z_curve (f_z_val := impl__Scalar__from_public_byte_seq_be (impl_52__from_vec temp))) in
  prod_b (source,hax_temp_output))) : both (v_R × t_Result t_Z_curve t_ParseError) in
  {| f_deserial := (@f_deserial)|}.
Fail Next Obligation.
Hint Unfold t_Z_curve_t_Deserial.

#[global] Program Instance t_Z_curve_t_Serial : t_Serial t_Z_curve :=
  let f_serial := fun  (self : both t_Z_curve) (out : both v_W) => letb (v : t_Vec int8 t_Global) := impl__new in
  letb v := foldi_both_list (f_into_iter (impl_41__native_slice (impl__Scalar__to_public_byte_seq_be (f_z_val self)))) (fun x =>
    ssp (fun v =>
      impl_1__push v (f_clone x) : (both (t_Vec int8 t_Global)))) v in
  letb '(tmp0,out1) := f_serial v out in
  letb out := tmp0 in
  letb hax_temp_output := out1 in
  prod_b (out,hax_temp_output) : both (v_W × t_Result 'unit f_Err) in
  {| f_serial := (@f_serial)|}.
Fail Next Obligation.
Hint Unfold t_Z_curve_t_Serial.

#[global] Program Instance t_Group_curve_t_Deserial : t_Deserial t_Group_curve :=
  let f_deserial := fun  (source : both v_R) => run (letb '(tmp0,out) := f_get source in
  letb source := tmp0 in
  letb hoist6 := out in
  letb hoist7 := f_branch hoist6 in
  letm[choice_typeMonad.result_bind_code (v_R × t_Result t_Group_curve t_ParseError)] (b : 'bool) := matchb hoist7 with
  | ControlFlow_Break_case residual =>
    letb residual := ret_both ((residual) : (t_Result t_Infallible t_ParseError)) in
    letm[choice_typeMonad.result_bind_code (v_R × t_Result t_Group_curve t_ParseError)] hoist5 := ControlFlow_Break (prod_b (source,f_from_residual residual)) in
    ControlFlow_Continue (never_to_any hoist5)
  | ControlFlow_Continue_case val =>
    letb val := ret_both ((val) : ('bool)) in
    ControlFlow_Continue val
  end in
  letm[choice_typeMonad.result_bind_code (v_R × t_Result t_Group_curve t_ParseError)] '(source,hax_temp_output) := ifb b
  then letb '(tmp0,out) := f_get source in
  letb source := tmp0 in
  letb hoist9 := out in
  letb hoist10 := f_branch hoist9 in
  letm[choice_typeMonad.result_bind_code (v_R × t_Result t_Group_curve t_ParseError)] (vx : t_Vec int8 t_Global) := matchb hoist10 with
  | ControlFlow_Break_case residual =>
    letb residual := ret_both ((residual) : (t_Result t_Infallible t_ParseError)) in
    letm[choice_typeMonad.result_bind_code (v_R × t_Result t_Group_curve t_ParseError)] hoist8 := ControlFlow_Break (prod_b (source,f_from_residual residual)) in
    ControlFlow_Continue (never_to_any hoist8)
  | ControlFlow_Continue_case val =>
    letb val := ret_both ((val) : (t_Vec int8 t_Global)) in
    ControlFlow_Continue val
  end in
  letb '(tmp0,out) := f_get source in
  letb source := tmp0 in
  letb hoist12 := out in
  letb hoist13 := f_branch hoist12 in
  letm[choice_typeMonad.result_bind_code (v_R × t_Result t_Group_curve t_ParseError)] (vy : t_Vec int8 t_Global) := matchb hoist13 with
  | ControlFlow_Break_case residual =>
    letb residual := ret_both ((residual) : (t_Result t_Infallible t_ParseError)) in
    letm[choice_typeMonad.result_bind_code (v_R × t_Result t_Group_curve t_ParseError)] hoist11 := ControlFlow_Break (prod_b (source,f_from_residual residual)) in
    ControlFlow_Continue (never_to_any hoist11)
  | ControlFlow_Continue_case val =>
    letb val := ret_both ((val) : (t_Vec int8 t_Global)) in
    ControlFlow_Continue val
  end in
  ControlFlow_Continue (prod_b (source,Result_Ok (Build_t_Group_curve (f_g_val := Point_Affine (prod_b (impl__FieldElement__from_public_byte_seq_be (impl_52__from_vec vx),impl__FieldElement__from_public_byte_seq_be (impl_52__from_vec vy)))))))
  else ControlFlow_Continue (prod_b (source,Result_Ok (Build_t_Group_curve (f_g_val := Point_AtInfinity)))) in
  ControlFlow_Continue (prod_b (source,hax_temp_output))) : both (v_R × t_Result t_Group_curve t_ParseError) in
  {| f_deserial := (@f_deserial)|}.
Fail Next Obligation.
Hint Unfold t_Group_curve_t_Deserial.

#[global] Program Instance t_Group_curve_t_Serial : t_Serial t_Group_curve :=
  let f_serial := fun  (self : both t_Group_curve) (out : both v_W) => run (letm[choice_typeMonad.result_bind_code (v_W × t_Result 'unit f_Err)] out := matchb f_g_val self with
  | Point_Affine_case p =>
    letb p := ret_both ((p) : (t_FieldElement × t_FieldElement)) in
    letb '(tmp0,out1) := f_serial (ret_both (true : 'bool)) out in
    letb out := tmp0 in
    letb hoist15 := out1 in
    letb hoist16 := f_branch hoist15 in
    letm[choice_typeMonad.result_bind_code (v_W × t_Result 'unit f_Err)] _ := matchb hoist16 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible f_Err)) in
      letm[choice_typeMonad.result_bind_code (v_W × t_Result 'unit f_Err)] hoist14 := ControlFlow_Break (prod_b (out,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist14)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : ('unit)) in
      ControlFlow_Continue val
    end in
    letb (vx : t_Vec int8 t_Global) := impl__new in
    letb vx := foldi_both_list (f_into_iter (impl_41__native_slice (impl__FieldElement__to_public_byte_seq_be (x p)))) (fun x =>
      ssp (fun vx =>
        impl_1__push vx (f_clone x) : (both (t_Vec int8 t_Global)))) vx in
    letb '(tmp0,out1) := f_serial vx out in
    letb out := tmp0 in
    letb hoist18 := out1 in
    letb hoist19 := f_branch hoist18 in
    letm[choice_typeMonad.result_bind_code (v_W × t_Result 'unit f_Err)] _ := matchb hoist19 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible f_Err)) in
      letm[choice_typeMonad.result_bind_code (v_W × t_Result 'unit f_Err)] hoist17 := ControlFlow_Break (prod_b (out,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist17)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : ('unit)) in
      ControlFlow_Continue val
    end in
    letb (vy : t_Vec int8 t_Global) := impl__new in
    letb vy := foldi_both_list (f_into_iter (impl_41__native_slice (impl__FieldElement__to_public_byte_seq_be (y p)))) (fun y =>
      ssp (fun vy =>
        impl_1__push vy (f_clone y) : (both (t_Vec int8 t_Global)))) vy in
    letb '(tmp0,out1) := f_serial vy out in
    letb out := tmp0 in
    letb hoist21 := out1 in
    letb hoist22 := f_branch hoist21 in
    letm[choice_typeMonad.result_bind_code (v_W × t_Result 'unit f_Err)] _ := matchb hoist22 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible f_Err)) in
      letm[choice_typeMonad.result_bind_code (v_W × t_Result 'unit f_Err)] hoist20 := ControlFlow_Break (prod_b (out,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist20)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : ('unit)) in
      ControlFlow_Continue val
    end in
    ControlFlow_Continue out
  | Point_AtInfinity_case  =>
    letb '(tmp0,out1) := f_serial (ret_both (false : 'bool)) out in
    letb out := tmp0 in
    letb hoist24 := out1 in
    letb hoist25 := f_branch hoist24 in
    letm[choice_typeMonad.result_bind_code (v_W × t_Result 'unit f_Err)] _ := matchb hoist25 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible f_Err)) in
      letm[choice_typeMonad.result_bind_code (v_W × t_Result 'unit f_Err)] hoist23 := ControlFlow_Break (prod_b (out,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist23)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : ('unit)) in
      ControlFlow_Continue val
    end in
    ControlFlow_Continue out
  end in
  ControlFlow_Continue (letb hax_temp_output := Result_Ok (ret_both (tt : 'unit)) in
  prod_b (out,hax_temp_output))) : both (v_W × t_Result 'unit f_Err) in
  {| f_serial := (@f_serial)|}.
Fail Next Obligation.
Hint Unfold t_Group_curve_t_Serial.

#[global] Program Instance t_Z_curve_t_Mul : t_Mul t_Z_curve t_Z_curve :=
  let f_Output := t_Z_curve : choice_type in
  let f_mul := fun  (self : both t_Z_curve) (y : both t_Z_curve) => Build_t_Z_curve (f_z_val := (f_z_val self) .* (f_z_val y)) : both t_Z_curve in
  {| f_Output := (@f_Output);
  f_mul := (@f_mul)|}.
Fail Next Obligation.
Hint Unfold t_Z_curve_t_Mul.

#[global] Program Instance t_Z_curve_t_Add : t_Add t_Z_curve t_Z_curve :=
  let f_Output := t_Z_curve : choice_type in
  let f_add := fun  (self : both t_Z_curve) (y : both t_Z_curve) => Build_t_Z_curve (f_z_val := (f_z_val self) .+ (f_z_val y)) : both t_Z_curve in
  {| f_Output := (@f_Output);
  f_add := (@f_add)|}.
Fail Next Obligation.
Hint Unfold t_Z_curve_t_Add.

#[global] Program Instance t_Group_curve_t_Mul : t_Mul t_Group_curve t_Group_curve :=
  let f_Output := t_Group_curve : choice_type in
  let f_mul := fun  (self : both t_Group_curve) (y : both t_Group_curve) => Build_t_Group_curve (f_g_val := point_add (f_g_val self) (f_g_val y)) : both t_Group_curve in
  {| f_Output := (@f_Output);
  f_mul := (@f_mul)|}.
Fail Next Obligation.
Hint Unfold t_Group_curve_t_Mul.

#[global] Program Instance t_Z_curve_t_Product : t_Product t_Z_curve t_Z_curve :=
  let f_product := fun  (iter : both v_I) => f_fold iter (Build_t_Z_curve (f_z_val := impl__Scalar__from_literal (ret_both (1 : int128)))) (fun a => fun b =>
    a .* b) : both t_Z_curve in
  {| f_product := (@f_product)|}.
Fail Next Obligation.
Hint Unfold t_Z_curve_t_Product.

#[global] Program Instance t_Z_curve_t_Field : t_Field t_Z_curve :=
  let f_q := fun  (_ : both 'unit) => Build_t_Z_curve (f_z_val := impl__Scalar__from_hex (ret_both (0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 : chString))) : both t_Z_curve in
  let f_random_field_elem := fun  (random : both int128) => Build_t_Z_curve (f_z_val := impl__Scalar__from_literal random) : both t_Z_curve in
  let f_field_zero := fun  (_ : both 'unit) => Build_t_Z_curve (f_z_val := impl__Scalar__from_literal (ret_both (0 : int128))) : both t_Z_curve in
  let f_field_one := fun  (_ : both 'unit) => Build_t_Z_curve (f_z_val := impl__Scalar__from_literal (ret_both (1 : int128))) : both t_Z_curve in
  let f_add := fun  (x : both t_Z_curve) (y : both t_Z_curve) => x .+ y : both t_Z_curve in
  let f_opp := fun  (x : both t_Z_curve) => f_neg x : both t_Z_curve in
  let f_mul := fun  (x : both t_Z_curve) (y : both t_Z_curve) => x .* y : both t_Z_curve in
  let f_inv := fun  (x : both t_Z_curve) => run (letb _ := assert (ret_both (false : 'bool)) in
  letm[choice_typeMonad.result_bind_code t_Z_curve] hoist29 := ControlFlow_Break x in
  ControlFlow_Continue (never_to_any hoist29)) : both t_Z_curve in
  {| f_q := (@f_q);
  f_random_field_elem := (@f_random_field_elem);
  f_field_zero := (@f_field_zero);
  f_field_one := (@f_field_one);
  f_add := (@f_add);
  f_opp := (@f_opp);
  f_mul := (@f_mul);
  f_inv := (@f_inv)|}.
Fail Next Obligation.
Hint Unfold t_Z_curve_t_Field.

#[global] Program Instance t_Z_curve_t_Neg : t_Neg t_Z_curve :=
  let f_Output := t_Z_curve : choice_type in
  let f_neg := fun  (self : both t_Z_curve) => Build_t_Z_curve (f_z_val := (f_z_val f_field_zero) .- (f_z_val self)) : both t_Z_curve in
  {| f_Output := (@f_Output);
  f_neg := (@f_neg)|}.
Fail Next Obligation.
Hint Unfold t_Z_curve_t_Neg.

#[global] Program Instance t_Group_curve_t_Group : t_Group t_Group_curve :=
  let f_Z := t_Z_curve : choice_type in
  let f_g := fun  (_ : both 'unit) => letb gx := PBytes32 (array_from_list [ret_both (121 : int8);
    ret_both (190 : int8);
    ret_both (102 : int8);
    ret_both (126 : int8);
    ret_both (249 : int8);
    ret_both (220 : int8);
    ret_both (187 : int8);
    ret_both (172 : int8);
    ret_both (85 : int8);
    ret_both (160 : int8);
    ret_both (98 : int8);
    ret_both (149 : int8);
    ret_both (206 : int8);
    ret_both (135 : int8);
    ret_both (11 : int8);
    ret_both (7 : int8);
    ret_both (2 : int8);
    ret_both (155 : int8);
    ret_both (252 : int8);
    ret_both (219 : int8);
    ret_both (45 : int8);
    ret_both (206 : int8);
    ret_both (40 : int8);
    ret_both (217 : int8);
    ret_both (89 : int8);
    ret_both (242 : int8);
    ret_both (129 : int8);
    ret_both (91 : int8);
    ret_both (22 : int8);
    ret_both (248 : int8);
    ret_both (23 : int8);
    ret_both (152 : int8)]) in
  letb gy := PBytes32 (array_from_list [ret_both (72 : int8);
    ret_both (58 : int8);
    ret_both (218 : int8);
    ret_both (119 : int8);
    ret_both (38 : int8);
    ret_both (163 : int8);
    ret_both (196 : int8);
    ret_both (101 : int8);
    ret_both (93 : int8);
    ret_both (164 : int8);
    ret_both (251 : int8);
    ret_both (252 : int8);
    ret_both (14 : int8);
    ret_both (17 : int8);
    ret_both (8 : int8);
    ret_both (168 : int8);
    ret_both (253 : int8);
    ret_both (23 : int8);
    ret_both (180 : int8);
    ret_both (72 : int8);
    ret_both (166 : int8);
    ret_both (133 : int8);
    ret_both (84 : int8);
    ret_both (25 : int8);
    ret_both (156 : int8);
    ret_both (71 : int8);
    ret_both (208 : int8);
    ret_both (143 : int8);
    ret_both (251 : int8);
    ret_both (16 : int8);
    ret_both (212 : int8);
    ret_both (184 : int8)]) in
  Build_t_Group_curve (f_g_val := Point_Affine (prod_b (impl__FieldElement__from_public_byte_seq_be gx,impl__FieldElement__from_public_byte_seq_be gy))) : both t_Group_curve in
  let f_pow := fun  (g : both t_Group_curve) (x : both t_Z_curve) => Build_t_Group_curve (f_g_val := point_mul (f_z_val x) (f_g_val g)) : both t_Group_curve in
  let f_g_pow := fun  (x : both t_Z_curve) => Build_t_Group_curve (f_g_val := point_mul_base (f_z_val x)) : both t_Group_curve in
  let f_group_one := fun  (_ : both 'unit) => f_g_pow f_field_zero : both t_Group_curve in
  let f_group_inv := fun  (x : both t_Group_curve) => Build_t_Group_curve (f_g_val := matchb f_g_val x with
  | Point_Affine_case (a,b) =>
    letb '(a,b) := ret_both (((a,b)) : (t_FieldElement × t_FieldElement)) in
    Point_Affine (prod_b (a,(impl__FieldElement__from_literal (ret_both (0 : int128))) .- b))
  | Point_AtInfinity_case  =>
    Point_AtInfinity
  end) : both t_Group_curve in
  let f_hash := fun  (x : both (t_Vec t_Group_curve t_Global)) => f_field_one : both t_Z_curve in
  let f_prod := fun  (x : both t_Group_curve) (y : both t_Group_curve) => x .* y : both t_Group_curve in
  {| f_Z := (@f_Z);
  f_g := (@f_g);
  f_pow := (@f_pow);
  f_g_pow := (@f_g_pow);
  f_group_one := (@f_group_one);
  f_group_inv := (@f_group_inv);
  f_hash := (@f_hash);
  f_prod := (@f_prod)|}.
Fail Next Obligation.
Hint Unfold t_Group_curve_t_Group.

#[global] Program Instance t_Group_curve_t_Product : t_Product t_Group_curve t_Group_curve :=
  let f_product := fun  (iter : both v_I) => f_fold iter (f_g_pow f_field_zero) (fun a => fun b =>
    a .* b) : both t_Group_curve in
  {| f_product := (@f_product)|}.
Fail Next Obligation.
Hint Unfold t_Group_curve_t_Product.

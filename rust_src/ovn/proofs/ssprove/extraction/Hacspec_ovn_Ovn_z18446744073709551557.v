(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From SSProve Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Require Import Hacspec_concordium.
Export Hacspec_concordium.

Require Import Crate_Ovn_traits.
Export Crate_Ovn_traits.

Definition t_g_z_18446744073709551557 : choice_type :=
  (int64).
Equations f_g_val (s : both t_g_z_18446744073709551557) : both int64 :=
  f_g_val s  :=
    bind_both s (fun x =>
      ret_both (x : int64)) : both int64.
Fail Next Obligation.
Equations Build_t_g_z_18446744073709551557 {f_g_val : both int64} : both (t_g_z_18446744073709551557) :=
  Build_t_g_z_18446744073709551557  :=
    bind_both f_g_val (fun f_g_val =>
      ret_both ((f_g_val) : (t_g_z_18446744073709551557))) : both (t_g_z_18446744073709551557).
Fail Next Obligation.
Notation "'Build_t_g_z_18446744073709551557' '[' x ']' '(' 'f_g_val' ':=' y ')'" := (Build_t_g_z_18446744073709551557 (f_g_val := y)).

Definition t_z_18446744073709551557 : choice_type :=
  (int64).
Equations f_z_val (s : both t_z_18446744073709551557) : both int64 :=
  f_z_val s  :=
    bind_both s (fun x =>
      ret_both (x : int64)) : both int64.
Fail Next Obligation.
Equations Build_t_z_18446744073709551557 {f_z_val : both int64} : both (t_z_18446744073709551557) :=
  Build_t_z_18446744073709551557  :=
    bind_both f_z_val (fun f_z_val =>
      ret_both ((f_z_val) : (t_z_18446744073709551557))) : both (t_z_18446744073709551557).
Fail Next Obligation.
Notation "'Build_t_z_18446744073709551557' '[' x ']' '(' 'f_z_val' ':=' y ')'" := (Build_t_z_18446744073709551557 (f_z_val := y)).

#[global] Program Instance t_z_18446744073709551557_t_Product : t_Product t_z_18446744073709551557 t_z_18446744073709551557 :=
  let f_product := fun  (iter : both v_I) => f_fold iter (Build_t_C_z_18446744073709551557 (f_z_val := ret_both (1 : int64))) (fun a => fun b =>
    a .* b) : both t_z_18446744073709551557 in
  {| f_product := (@f_product)|}.
Fail Next Obligation.
Hint Unfold t_z_18446744073709551557_t_Product.

#[global] Program Instance t_g_z_18446744073709551557_t_Product : t_Product t_g_z_18446744073709551557 t_g_z_18446744073709551557 :=
  let f_product := fun  (iter : both v_I) => f_fold iter (Build_t_C_g_z_18446744073709551557 (f_g_val := ret_both (1 : int64))) (fun a => fun b =>
    a .* b) : both t_g_z_18446744073709551557 in
  {| f_product := (@f_product)|}.
Fail Next Obligation.
Hint Unfold t_g_z_18446744073709551557_t_Product.

#[global] Program Instance t_z_18446744073709551557_t_Mul : t_Mul t_z_18446744073709551557 t_z_18446744073709551557 :=
  let f_Output := t_z_18446744073709551557 : choice_type in
  let f_mul := fun  (self : both t_z_18446744073709551557) (y : both t_z_18446744073709551557) => letb q___ := (f_z_val f_q) .- (ret_both (1 : int64)) in
  letb (x___ : int128) := cast_int (WS2 := _) ((f_z_val self) .% q___) in
  letb (y___ : int128) := cast_int (WS2 := _) ((f_z_val y) .% q___) in
  Build_t_C_z_18446744073709551557 (f_z_val := cast_int (WS2 := _) ((x___ .* y___) .% (cast_int (WS2 := _) q___))) : both t_z_18446744073709551557 in
  {| f_Output := (@f_Output);
  f_mul := (@f_mul)|}.
Fail Next Obligation.
Hint Unfold t_z_18446744073709551557_t_Mul.

#[global] Program Instance t_z_18446744073709551557_t_Add : t_Add t_z_18446744073709551557 t_z_18446744073709551557 :=
  let f_Output := t_z_18446744073709551557 : choice_type in
  let f_add := fun  (self : both t_z_18446744073709551557) (y : both t_z_18446744073709551557) => letb q___ := (f_z_val f_q) .- (ret_both (1 : int64)) in
  letb x___ := cast_int (WS2 := _) ((f_z_val self) .% q___) in
  letb y___ := cast_int (WS2 := _) ((f_z_val y) .% q___) in
  Build_t_C_z_18446744073709551557 (f_z_val := cast_int (WS2 := _) ((x___ .+ y___) .% (cast_int (WS2 := _) q___))) : both t_z_18446744073709551557 in
  {| f_Output := (@f_Output);
  f_add := (@f_add)|}.
Fail Next Obligation.
Hint Unfold t_z_18446744073709551557_t_Add.

#[global] Program Instance t_z_18446744073709551557_t_Neg : t_Neg t_z_18446744073709551557 :=
  let f_Output := t_z_18446744073709551557 : choice_type in
  let f_neg := fun  (self : both t_z_18446744073709551557) => letb q___ := (f_z_val f_q) .- (ret_both (1 : int64)) in
  letb x___ := (f_z_val self) .% q___ in
  Build_t_C_z_18446744073709551557 (f_z_val := q___ .- x___) : both t_z_18446744073709551557 in
  {| f_Output := (@f_Output);
  f_neg := (@f_neg)|}.
Fail Next Obligation.
Hint Unfold t_z_18446744073709551557_t_Neg.

#[global] Program Instance t_z_18446744073709551557_t_Field : t_Field t_z_18446744073709551557 :=
  let f_q := fun  (_ : both 'unit) => Build_t_C_z_18446744073709551557 (f_z_val := ret_both (18446744073709551557 : int64)) : both t_z_18446744073709551557 in
  let f_random_field_elem := fun  (random : both int128) => Build_t_C_z_18446744073709551557 (f_z_val := (cast_int (WS2 := _) random) .% ((f_z_val f_q) .- (ret_both (1 : int64)))) : both t_z_18446744073709551557 in
  let f_field_zero := fun  (_ : both 'unit) => Build_t_C_z_18446744073709551557 (f_z_val := ret_both (0 : int64)) : both t_z_18446744073709551557 in
  let f_field_one := fun  (_ : both 'unit) => Build_t_C_z_18446744073709551557 (f_z_val := ret_both (1 : int64)) : both t_z_18446744073709551557 in
  let f_inv := fun  (x : both t_z_18446744073709551557) => run (letb _ := assert (ret_both (false : 'bool)) in
  letm[choice_typeMonad.result_bind_code t_z_18446744073709551557] hoist5 := ControlFlow_Break x in
  ControlFlow_Continue (never_to_any hoist5)) : both t_z_18446744073709551557 in
  let f_add := fun  (x : both t_z_18446744073709551557) (y : both t_z_18446744073709551557) => x .+ y : both t_z_18446744073709551557 in
  let f_opp := fun  (x : both t_z_18446744073709551557) => f_neg x : both t_z_18446744073709551557 in
  let f_mul := fun  (x : both t_z_18446744073709551557) (y : both t_z_18446744073709551557) => x .* y : both t_z_18446744073709551557 in
  {| f_q := (@f_q);
  f_random_field_elem := (@f_random_field_elem);
  f_field_zero := (@f_field_zero);
  f_field_one := (@f_field_one);
  f_inv := (@f_inv);
  f_add := (@f_add);
  f_opp := (@f_opp);
  f_mul := (@f_mul)|}.
Fail Next Obligation.
Hint Unfold t_z_18446744073709551557_t_Field.

#[global] Program Instance t_g_z_18446744073709551557_t_Mul : t_Mul t_g_z_18446744073709551557 t_g_z_18446744073709551557 :=
  let f_Output := t_g_z_18446744073709551557 : choice_type in
  let f_mul := fun  (self : both t_g_z_18446744073709551557) (y : both t_g_z_18446744073709551557) => letb q___ := f_z_val f_q in
  letb x___ := cast_int (WS2 := _) ((f_g_val self) .% q___) in
  letb y___ := cast_int (WS2 := _) ((f_g_val y) .% q___) in
  Build_t_C_g_z_18446744073709551557 (f_g_val := cast_int (WS2 := _) ((x___ .* y___) .% (cast_int (WS2 := _) q___))) : both t_g_z_18446744073709551557 in
  {| f_Output := (@f_Output);
  f_mul := (@f_mul)|}.
Fail Next Obligation.
Hint Unfold t_g_z_18446744073709551557_t_Mul.

#[global] Program Instance t_g_z_18446744073709551557_t_Group : t_Group t_g_z_18446744073709551557 :=
  let f_Z := t_z_18446744073709551557 : choice_type in
  let f_g := fun  (_ : both 'unit) => Build_t_C_g_z_18446744073709551557 (f_g_val := ret_both (2 : int64)) : both t_g_z_18446744073709551557 in
  let f_hash := fun  (x : both (t_Vec t_g_z_18446744073709551557 t_Global)) => letb res := f_field_one in
  letb res := foldi_both_list (f_into_iter x) (fun y =>
    ssp (fun res =>
      (Build_t_C_z_18446744073709551557 (f_z_val := f_g_val y)) .* res : (both t_z_18446744073709551557))) res in
  res : both t_z_18446744073709551557 in
  let f_g_pow := fun  (x : both t_z_18446744073709551557) => f_pow f_g x : both t_g_z_18446744073709551557 in
  let f_pow := fun  (g : both t_g_z_18446744073709551557) (x : both t_z_18446744073709551557) => letb result := f_group_one in
  letb power := g in
  letb (exps : int64) := (f_z_val x) .% ((f_z_val f_q) .- (ret_both (1 : int64))) in
  letb '(exps,power,result) := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (0 : int32)) (f_end := ret_both (64 : int32)))) (fun _ =>
    ssp (fun '(exps,power,result) =>
      letb result := ifb (exps .& (ret_both (1 : int64))) =.? (ret_both (1 : int64))
      then letb result := f_prod result power in
      result
      else result in
      letb power := f_prod power power in
      letb exps := exps shift_right (ret_both (1 : int32)) in
      prod_b (exps,power,result) : (both (int64 × t_g_z_18446744073709551557 × t_g_z_18446744073709551557)))) (prod_b (exps,power,result)) in
  result : both t_g_z_18446744073709551557 in
  let f_group_one := fun  (_ : both 'unit) => Build_t_C_g_z_18446744073709551557 (f_g_val := ret_both (1 : int64)) : both t_g_z_18446744073709551557 in
  let f_group_inv := fun  (x : both t_g_z_18446744073709551557) => letb p_sub_2_ := Build_t_C_z_18446744073709551557 (f_z_val := (ret_both (18446744073709551557 : int64)) .- (ret_both (2 : int64))) in
  f_pow x p_sub_2_ : both t_g_z_18446744073709551557 in
  let f_prod := fun  (x : both t_g_z_18446744073709551557) (y : both t_g_z_18446744073709551557) => x .* y : both t_g_z_18446744073709551557 in
  {| f_Z := (@f_Z);
  f_g := (@f_g);
  f_hash := (@f_hash);
  f_g_pow := (@f_g_pow);
  f_pow := (@f_pow);
  f_group_one := (@f_group_one);
  f_group_inv := (@f_group_inv);
  f_prod := (@f_prod)|}.
Fail Next Obligation.
Hint Unfold t_g_z_18446744073709551557_t_Group.
